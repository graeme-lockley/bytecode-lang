let Bytecode = import("./bytecode.rebo")
let Parser = import("./parser.rebo")

let compile(ast) {
   let bc = _codegen()
   let env = {}
   let globalOffset = 0

   ast |> each(fn(stmt)
      match stmt
      | { kind: "Var", name, value } -> {
         if env[name] != () -> raise { kind: "CompilerError", reason: "compile: Variable already defined", ast: stmt }

         let vtype = _compileExpr(bc, env, value)

         if vtype != "Int" -> raise { kind: "CompilerError", reason: "compile: Only Ints are supported", ast: stmt }

         env[stmt.name] := { kind: "Var", offset: globalOffset }
         globalOffset := globalOffset + 1
      }
      | { kind: "Print", args } -> {
         args |> each(fn(arg) {
            let vtype = _compileExpr(bc, env, arg)

            match vtype
            | "Bool" -> bc.appendInstruction(Bytecode.PRINTB)
            | "Int" -> bc.appendInstruction(Bytecode.PRINTI)
            | "String" -> bc.appendInstruction(Bytecode.PRINTS)
            | _ -> raise { kind: "CompilerError", reason: "compile: Incompatible type", ast: stmt }
         })
      }
      | { kind: "Println", args } -> {
         args |> each(fn(arg) {
            let vtype = _compileExpr(bc, env, arg)

            match vtype
            | "Bool" -> bc.appendInstruction(Bytecode.PRINTB)
            | "Int" -> bc.appendInstruction(Bytecode.PRINTI)
            | "String" -> bc.appendInstruction(Bytecode.PRINTS)
            | _ -> raise { kind: "CompilerError", reason: "compile: Incompatible type", ast: stmt }
         })
         bc.appendInstruction(Bytecode.PRINTLN)
      }
      | _ -> raise { kind: "CompilerError", reason: "compile: Not implemented", ast: stmt }
   )

   bc.code()
}

let _compileExpr(bc, env, expr) =
   match expr
   | { kind: "Identifier", value } -> {
      let var = env[value]

      if var == () -> raise { kind: "CompilerError", reason: "_compileExpr: Variable not found", ast: expr }

      bc.appendInstruction(Bytecode.PUSH)
      bc.appendInt(var.offset)

      "Int"
   }
   | { kind: "LiteralBool", value } -> {
      bc.appendInstruction(Bytecode.PUSHI)
      bc.appendInt(if value -> 1 | 0)

      "Bool"
   }
   | { kind: "LiteralInt", value } -> {
      bc.appendInstruction(Bytecode.PUSHI)
      bc.appendInt(value)

      "Int"
   }
   | { kind: "LiteralString", value } -> {
      bc.appendInstruction(Bytecode.PUSHS)
      bc.appendInt(len(value))
      bc.appendString(value)

      "String"
   }
   | _ -> raise { kind: "CompilerError", reason: "_compileExpr: Not implemented", ast: expr }


let compilerDis(input) =
   Parser.parse(input) |> compile() |> Bytecode.disassemble()

let _codegen() {
   let bc = ""

   {
      appendInstruction: fn(op) {
         bc := bc + str(op, false)
      },
      appendInt: fn(n) {
         bc := bc + str([char(n % 256), char((n / 256) % 256), char((n / 65536) % 256), char((n / 16777216) % 256)], false)
      },
      appendString: fn(s) {
         bc := bc + s
      },
      code: fn() bc
   }
}
